#!/bin/bash

# This file is meant to be run from the project root folder and receive, as
# argument, the filename (with extension) of the file to create the test from.

# REFERENCES:
# https://github.com/VitexSoftware/phpunit-skeleton-generator
# https://stackoverflow.com/questions/8880603/loop-through-an-array-of-strings-in-bash
# https://askubuntu.com/questions/674333/how-to-pass-an-array-as-function-argument
# https://stackoverflow.com/questions/57585770/bash-for-loop-skip-first-element-of-array
# https://unix.stackexchange.com/questions/180613/bash-find-get-directory-of-found-file
# https://stackoverflow.com/questions/3915040/how-to-obtain-the-absolute-path-of-a-file-via-shell-bash-zsh-sh
# https://stackoverflow.com/questions/13210880/replace-one-substring-for-another-string-in-shell-script
# https://stackoverflow.com/questions/793858/how-to-mkdir-only-if-a-directory-does-not-already-exist


include() {
    # # ONLY FOR DEBUG:
    # MY_DIR="/var/www/html/php-boilerplate/src/sh"

    # MY_DIR is the <project_root>/src/sh directory.
    MY_DIR=$(dirname $(readlink -f $0))

    . $MY_DIR/$1
}

# Included files
include "utils.sh"

# Gets the relative folder path to the file given as argument.
# param1 (string): Only the filename with extension, not the path.
get_file_relative_folder() {
    local src_folder="./src/"
    local file_relative_folder=$(find "$src_folder" -name "$1" -printf '%h\n')
    echo "$file_relative_folder"
}

# Gets the namespace of the file given as argument.
# param1 (string): Full file path of the opened file.
# return (string): The complete namespace as it exists in the opened (class) file.
get_file_namespace() {
    local file_full_path="$1"

    local line_with_namespace=$(grep -w '^namespace' $file_full_path)
    local complete_namespace=${line_with_namespace/namespace /}
    complete_namespace=$(echo "${complete_namespace%%;*}")

    # Return
    echo "$complete_namespace"
}

# Gets the class name of the file given as argument.
# param1 (string): Full file path of the opened file.
# return (string): The class name as it exists in the opened (class) file.
get_class_name() {
    # Find the class name inside the opened file.
    local line_containing_class_name=$(grep -w '^class' "$1")
    local class_name=${line_containing_class_name/class /}
    class_name=$(echo "${class_name%% *}")

    # Return
    echo "$class_name"
}

# BETTER NOT TO USE THIS FUNCTION AND KEEP THE AUTOMATIC TEXT GENERATED
# =====================================================================
# Inserts the PHPDoc class documentation in the file passed as argument.
# param1 (string): The path to the file where the string will be inserted.
# param2 (string): The namespace together with the class name of the opened file.
# return (string): The class documentation inserted.
# example:
# insert_phpdoc_class_documentation "$test_full_path" "$file_namespace_and_class_name"
insert_phpdoc_class_documentation() {

    local match="Generated by PHPUnit_SkeletonGenerator on .*$"
    local file="$1"

    local file_namespace_and_class_name="$2"
    local namespace_array=($(echo "$file_namespace_and_class_name" | tr '\' '\n'))

    local phpdoc_class_documentation="@covers  ${namespace_array[0]}\\\\${namespace_array[1]}\\\\${namespace_array[2]}\n"
    local root_namespace_with_dashes=${namespace_array[0]//_/-}
    phpdoc_class_documentation="${phpdoc_class_documentation} * @uses    <a href=\"${namespace_array[1]}\/${root_namespace_with_dashes}-${namespace_array[1]}-${namespace_array[2]}.html\">${namespace_array[0]}\\\\${namespace_array[1]}\\\\${namespace_array[2]}<\/a> to test its functionality."

    # s/AAAA/BBBB/options
    sed -i "s/$match/$phpdoc_class_documentation/" $file

    echo "${phpdoc_class_documentation}"
}

# Inserts the PHPDoc file header in the file passed as argument.
# param1 (string): The path to the file where the string will be inserted.
# return (string): The file documentation inserted.
insert_phpdoc_file_documentation() {

    local current_year=$(date +'%Y')
    local date=$(date '+%Y-%m-%d')

    # Gets the OS this script is running on.
    case "$OSTYPE" in
        solaris*|darwin*|linux*|bsd*)
            local php_version=$(php -v | awk 'NR<=1{ print $2 }')
            ;;
        msys*)
            local php_version=$("C:/PHP/php.exe" -v | awk 'NR<=1{ print $2 }')
            ;;
        *)
            local php_version="unknown"
            ;;
    esac

    # Modifies the line with the PHP version number.
    if [ $php_version = "unknown" ]; then
        local php_line=""
    else
        local php_line=" * PHP version ${php_version}<br \/>\n"
    fi

    local phpdoc_file_documentation="\/**\n"
    phpdoc_file_documentation="${phpdoc_file_documentation} * An example test class to show syntax and documentation.\n"
    phpdoc_file_documentation="${phpdoc_file_documentation} *\n"
    phpdoc_file_documentation="${phpdoc_file_documentation} * This test class is only an example to serve as a reference or be deleted.<br \/>\n"
    phpdoc_file_documentation="${phpdoc_file_documentation} * Last modified in ${date}<br \/>\n"
    phpdoc_file_documentation="${phpdoc_file_documentation}${php_line}"
    phpdoc_file_documentation="${phpdoc_file_documentation} *\n"
    phpdoc_file_documentation="${phpdoc_file_documentation} * @copyright   ${current_year} Leonardo Pinheiro\n"
    phpdoc_file_documentation="${phpdoc_file_documentation} * @author      __Leonardo Pinheiro__ <info@leonardopinheiro.net>\n"
    phpdoc_file_documentation="${phpdoc_file_documentation} * @link        https:\/\/www.leonardopinheiro.net Leonardo Pinheiro Designer's website\n"
    phpdoc_file_documentation="${phpdoc_file_documentation} *\n"
    phpdoc_file_documentation="${phpdoc_file_documentation} * @see         https:\/\/stackoverflow.com\/questions\/45506414\/how-to-document-phpunit-tests How to document PHPUnit tests\n"
    phpdoc_file_documentation="${phpdoc_file_documentation} *\/\n"

    local match="<?php"
    local file="$1"

    # s/AAAA/BBBB/options
    sed -i "s/$match/$match\n\n$phpdoc_file_documentation/" $file

    # Return
    echo "$phpdoc_file_documentation"
}

# Inserts the require_once statement.
# param1 (string): The test full file path.
# return (string): The require_once statement.
insert_require_once() {

    local test_full_path="$1"

    # Breaks the path into an array.
    local path_array=($(echo "$test_full_path" | tr '/' '\n'))

    # Removes the last item of the array (test name with extension).
    unset path_array[-1]

    # Levels up substring.
    local one_level_up="\/.."
    local levels_up=""

    # The counter of levels.
    local level_counter=0

    # Loops through array backwards.
    for (( idx=${#path_array[@]}-1 ; idx>=0 ; idx-- )) ; do

        (( level_counter++ ))

        if [[ "${path_array[idx]}" = "tests" ]]; then
            break
        fi
    done

    # Builds the substring with the levels to go up.
    for (( index=0 ; index<=${level_counter}-1 ; index++ )) ; do
        levels_up="${levels_up}${one_level_up}"
    done

    local require_once_statement="require_once(__DIR__ . '${levels_up}\/vendor\/autoload.php');"

    local match="$(grep -w '^namespace' "$test_full_path")"
    match=${match//\\/\\\\}
    local file="$test_full_path"

    # s/AAAA/BBBB/options
    sed -i "s/$match/$match\n\n$require_once_statement/" $file

    # Return
    echo "$require_once_statement"
}

# Creates a test file.
# param1 (string): The ${fileBasename} (filename with extension) from the VSCODE task.
main() {

    clear

    # Receives the ${fileBasename} (filename with extension) from the VSCODE task.
    current_opened_file="$1"

    # Verifies if the argument was passed, and if the file exists.
    # https://stackoverflow.com/a/21164441
    if [ -f $current_opened_file ]; then
        print_error_message "This script receives, as argument, the name of the php file (with extension) that is going to be tested.\nThe file must be in the src folder or inside a subfolder."
        exit 1
    elif [[ $current_opened_file != *\.php ]]; then
        print_error_message "The file must have the \".php\" extension."
        exit 1
    fi

    # Builds the full file path to the opened file.
    local file_relative_folder=$(get_file_relative_folder "$current_opened_file")
    local file_full_folder_path=$(realpath $file_relative_folder)
    local file_full_path="${file_full_folder_path}/${current_opened_file}"

    if [[ ! -f $file_full_path ]]; then
        print_error_message "File (from which the test will be created) not found in the src folder or in its subfolders."
        exit 1
    fi

    # Creates the full folder path for the test file that will be created.
    local tests_replacement="tests/src"
    local tests_full_folder_path=${file_full_folder_path/src/"$tests_replacement"}

    # Creates the path in the tests folder if necessary.
    if [ ! -d $tests_full_folder_path ]; then
        mkdir -p $tests_full_folder_path
    fi

    # Builds the namespace with the class name.
    local file_namespace=$(get_file_namespace "$file_full_path")
    local file_class_name=$(get_class_name "$file_full_path")
    local file_namespace_and_class_name="${file_namespace}\\${file_class_name}"

    # Builds the test's namespace.
    local test_namespace_sufix="${file_namespace_and_class_name}Test"

    # Builds the test's full path.
    local test_full_path="${tests_full_folder_path}/${current_opened_file}"
    test_full_path=${test_full_path/.php/Test.php}

    # When passing arguments to phpunit-skeleton-generator,
    # the Cygwin prefix /cygdrive/c must be removed.
    if [[ "$file_full_path" =~ ^\/cygdrive\/c ]]; then
        file_full_path=${file_full_path/\/cygdrive\/c/C\:}
    fi

    if [[ "$test_full_path" =~ ^\/cygdrive\/c ]]; then
        test_full_path=${test_full_path/\/cygdrive\/c/C\:}
    fi

    # Creates the test file.
    # https://github.com/cyberpearuk/phpunit-skelgen#usage
    # ./vendor/bin/phpunit-skelgen --ansi generate-test <namespace> <src-file> <test-class-name> <tst-file>
    vendor/bin/phpunit-skelgen generate-test $file_namespace_and_class_name $file_full_path $test_namespace_sufix $test_full_path

    # Inserts the documentation into file.
    insert_phpdoc_file_documentation "$test_full_path"

    # Inserts the require_once statement.
    insert_require_once "$test_full_path"

    # Formats the test file.
    vendor/bin/php-cs-fixer fix "$test_full_path"

    echo -e "\n\nThe test file was created successfully!"
    exit 0
}

# # ONLY FOR DEBUG:
# main "ExampleSuperclass.php"

main "$1"
